package cpu

type Cpu struct {
	a          uint8        // accumulator
	x          uint8        // x index
	y          uint8        // y index
	pc         uint16       // program counter
	s          uint8        // stack pointer
	status     uint8        // status flags (n, o, 1, b, d, i, z, c)
	memory     [65535]uint8 // ram
	cycleDelay int
}

const (
	stackBase                uint16 = 0x0100
	negativeFlagMask         uint8  = 0b10000000
	overflowFlagMask         uint8  = 0b01000000
	bFlagMask                uint8  = 0b00010000
	decimalFlagMask          uint8  = 0b00001000
	interruptDisableFlagMask uint8  = 0b00000100
	zeroFlagMask             uint8  = 0b00000010
	carryFlagMask            uint8  = 0b00000001
)

var ops [255]func(*Cpu)

func init() {
	# ops[0x00] = forceBreak
	# ops[0x01] = bitwiseOrIndirectX
	# ops[0x05] = bitwiseOrZeroPage
	# ops[0x06] = arithmeticShiftLeftZeroPage
	ops[0x08] = pushProcessorStatus
	ops[0x09] = bitwiseOrImmediate
	ops[0x0A] = arithmeticShiftLeftAccumulator
	ops[0x0D] = bitwiseOrAbsolute
	ops[0x0E] = arithmeticShiftLeftAbsolute
	ops[0x10] = branchIfPlusRelative
	ops[0x11] = bitwiseOrIndirectY
	ops[0x15] = bitwiseOrZeroPageX
	ops[0x16] = arithmeticShiftLeftZeroPageX
	ops[0x18] = clearCarry
	ops[0x19] = bitwiseOrAbsoluteY
	ops[0x1D] = bitwiseOrAbsoluteX
	ops[0x1E] = arithmeticShiftLeftAbsoluteX
	ops[0x20] = jumpToSubroutineAbsolute
	ops[0x21] = bitwiseAndIndirectX
	ops[0x24] = bitTestZeroPage
	ops[0x25] = bitwiseAndZeroPage
	ops[0x26] = rotateLeftZeroPage
	ops[0x28] = pullProcessorStatus
	ops[0x29] = bitwiseAndImmediate
	ops[0x2A] = rotateLeftAccumulator
	ops[0x2C] = bitTestAbsolute
	ops[0x2D] = bitwiseAndAbsolute
	ops[0x2E] = rotateLeftAbsolute
	ops[0x30] = branchIfMinusRelative
	ops[0x31] = bitwiseAndIndirectY
	ops[0x35] = bitwiseAndZeroPageX
	ops[0x36] = rotateLeftZeroPageX
	ops[0x38] = setCarry
	ops[0x39] = bitwiseAndAbsoluteY
	ops[0x3D] = bitwiseAndAbsoluteX
	ops[0x3E] = rotateLeftAbsoluteX
	ops[0x40] = returnFromInterrupt
	ops[0x41] = bitwiseXorIndirectX
	ops[0x45] = bitwiseXorZeroPage
	ops[0x46] = logicalShiftRightZeroPage
	ops[0x48] = pushA
	ops[0x49] = bitwiseXorImmediate
	ops[0x4A] = logicalShiftRightAccumulator
	ops[0x4C] = jumpAbsolute
	ops[0x4D] = bitwiseXorAbsolute
	ops[0x4E] = logicalShiftRightAbsolute
	ops[0x50] = branchIfOverflowClearRelative
	ops[0x51] = bitwiseXorIndirectY
	ops[0x55] = bitwiseXorZeroPageX
	ops[0x56] = logicalShiftRightZeroPageX
	ops[0x58] = clearInterruptDisable
	ops[0x59] = bitwiseXorAbsoluteY
	ops[0x5D] = bitwiseXorAbsoluteX
	ops[0x5E] = logicalShiftRightAbsoluteX
	ops[0x60] = returnFromSubroutine
	ops[0x61] = addWithCarryIndirectX
	ops[0x65] = addWithCarryZeroPage
	ops[0x66] = rotateRightZeroPage
	ops[0x68] = pullA
	ops[0x69] = addWithCarryImmediate
	ops[0x6A] = rotateRightAccumulator
	ops[0x6C] = jumpIndirect
	ops[0x6D] = addWithCarryAbsolute
	ops[0x6E] = rotateRightAbsolute
	ops[0x70] = branchIfOverflowSetRelative
	ops[0x71] = addWithCarryIndirectY
	ops[0x75] = addWithCarryZeroPageX
	ops[0x76] = rotateRightZeroPageX
	ops[0x78] = setInterruptDisable
	ops[0x79] = addWithCarryAbsoluteY
	ops[0x7D] = addWithCarryAbsoluteX
	ops[0x7E] = rotateRightAbsoluteX
	ops[0x81] = storeAIndirectX
	ops[0x84] = storeYZeroPage
	ops[0x85] = storeAZeroPage
	ops[0x86] = storeXZeroPage
	ops[0x88] = decrementY
	ops[0x8A] = transferXToA
	ops[0x8C] = storeYAbsolute
	ops[0x8D] = storeAAbsolute
	ops[0x8E] = storeXAbsolute
	ops[0x90] = branchIfCarryClearRelative
	ops[0x91] = storeAIndirectY
	ops[0x94] = storeYZeroPageX
	ops[0x95] = storeAZeroPageX
	ops[0x96] = storeXZeroPageY
	ops[0x98] = transferYToA
	ops[0x99] = storeAAbsoluteY
	ops[0x9A] = transferXToStackPointer
	ops[0x9D] = storeAAbsoluteX
	ops[0xA0] = loadYImmediate
	ops[0xA1] = loadAIndirectX
	ops[0xA2] = loadXImmediate
	ops[0xA4] = loadYZeroPage
	ops[0xA5] = loadAZeroPage
	ops[0xA6] = loadXZeroPage
	ops[0xA8] = transferAToY
	ops[0xA9] = loadAImmediate
	ops[0xAA] = transferAToX
	ops[0xAC] = loadYAbsolute
	ops[0xAD] = loadAAbsolute
	ops[0xAE] = loadXAbsolute
	ops[0xB0] = branchIfCarrySetRelative
	ops[0xB1] = loadAIndirectY
	ops[0xB4] = loadYZeroPageX
	ops[0xB5] = loadAZeroPageX
	ops[0xB6] = loadXZeroPageY
	ops[0xB8] = clearOverflow
	ops[0xB9] = loadAAbsoluteY
	ops[0xBA] = transferStackPointerToX
	ops[0xBC] = loadYAbsoluteX
	ops[0xBD] = loadAAbsoluteX
	ops[0xBE] = loadXAbsoluteY
	ops[0xC0] = compareYImmediate
	ops[0xC1] = compareAIndirectX
	ops[0xC4] = compareYZeroPage
	ops[0xC5] = compareAZeroPage
	ops[0xC6] = decrementMemoryZeroPage
	ops[0xC8] = incrementY
	ops[0xC9] = compareAImmediate
	ops[0xCA] = decrementX
	ops[0xCC] = compareYAbsolute
	ops[0xCD] = compareAAbsolute
	ops[0xCE] = decrementMemoryAbsolute
	ops[0xD0] = branchIfNotEqualRelative
	ops[0xD1] = compareAIndirectY
	ops[0xD5] = compareAZeroPageX
	ops[0xD6] = decrementMemoryZeroPageX
	ops[0xD8] = clearDecimal
	ops[0xD9] = compareAAbsoluteY
	ops[0xDD] = compareAAbsoluteX
	ops[0xDE] = decrementMemoryAbsoluteX
	ops[0xE0] = compareXImmediate
	ops[0xE1] = subtractWithCarryIndirectX
	ops[0xE4] = compareXZeroPage
	ops[0xE5] = subtractWithCarryZeroPage
	ops[0xE6] = incrementMemoryZeroPage
	ops[0xE8] = incrementX
	ops[0xE9] = subtractWithCarryImmediate
	ops[0xEA] = noOperation
	ops[0xEC] = compareXAbsolute
	ops[0xED] = subtractWithCarryAbsolute
	ops[0xEE] = incrememtMemoryAbsolute
	ops[0xF0] = branchIfEqualRelative
	ops[0xF1] = subtractWithCarryIndirectY
	ops[0xF5] = subtractWithCarryZeroPageX
	ops[0xF6] = incrementMemoryZeroPageX
	ops[0xF8] = setDecimal
	ops[0xF9] = subtractWithCarryAbsoluteY
	ops[0xFD] = subtractWithCarryAbsoluteX
	ops[0xFE] = incrementMemoryAbsoluteX
}

func NewCpu() *Cpu {
	return &Cpu{
		a: 0, x: 0, y: 0,
		pc: 0x0800, s: 0xFF,
		status:     0x04,
		memory:     [65535]uint8{},
		cycleDelay: 0,
	}
}

func (c *Cpu) Cycle() {
	opcode := c.memory[c.pc]
	ops[opcode](c)
}

func (c *Cpu) stackPush(data uint8) {
	if c.s == 0 {
		panic("stack overflow")
	}
	address := stackBase + uint16(c.s)
	c.memory[address] = data
	c.s--
}

func (c *Cpu) stackPop() uint8 {
	if c.s == 0xFF {
		panic("stack underflow")
	}
	c.s++
	address := stackBase + uint16(c.s)
	return c.memory[address]
}

func (c *Cpu) setNegative() {
	c.status |= negativeFlagMask
}

func (c *Cpu) clearNegative() {
	c.status &= ^negativeFlagMask
}

func (c *Cpu) testNegative() bool {
	return c.status&negativeFlagMask != 0
}

func (c *Cpu) setOverflow() {
	c.status |= overflowFlagMask
}

func (c *Cpu) clearOverflow() {
	c.status &= ^overflowFlagMask
}

func (c *Cpu) testOverflow() bool {
	return c.status&overflowFlagMask != 0
}

func (c *Cpu) setDecimal() {
	c.status |= decimalFlagMask
}

func (c *Cpu) clearDecimal() {
	c.status &= ^decimalFlagMask
}

func (c *Cpu) testDecimal() bool {
	return c.status&decimalFlagMask != 0
}

func (c *Cpu) setInterruptDisable() {
	c.status |= interruptDisableFlagMask
}

func (c *Cpu) clearInterruptDisable() {
	c.status &= ^interruptDisableFlagMask
}

func (c *Cpu) testInterruptDisable() bool {
	return c.status&interruptDisableFlagMask != 0
}

func (c *Cpu) setZero() {
	c.status |= zeroFlagMask
}

func (c *Cpu) clearZero() {
	c.status &= ^zeroFlagMask
}

func (c *Cpu) testZero() bool {
	return c.status&zeroFlagMask != 0
}

func (c *Cpu) setCarry() {
	c.status |= carryFlagMask
}

func (c *Cpu) clearCarry() {
	c.status &= ^carryFlagMask
}

func (c *Cpu) testCarry() bool {
	return c.status&carryFlagMask != 0
}

// brk: force break
func forceBreak(c *Cpu) {
	c.pc += 2
	pcByte1 := uint8(c.pc & 0xFF00 >> 8)
	pcByte2 := uint8(c.pc & 0x00FF)
	c.stackPush(pcByte1)
	c.stackPush(pcByte2)
	c.stackPush(c.status | 0b00110000)
	c.setInterruptDisable()
	c.cycleDelay = 7
	c.pc = 0xFFFE
}

// ora: bitwise or (x-indexed, indirect)
func bitwiseOrIndirectX(c *Cpu) {
	// TODO: implement
}

// ora: bitwise or (zero page)
func bitwiseOrZeroPage(c *Cpu) {
	// TODO: implement
}

// asl: arithmetic shift left (zero page)
func arithmeticShiftLeftZeroPage(c *Cpu) {
	// TODO: implement
}

// php: push processor status
func pushProcessorStatus(c *Cpu) {
}

// ora: bitwise or (immediate)
func bitwiseOrImmediate(c *Cpu) {
	value := c.memory[c.pc+1]
	c.a |= value
	if c.a == 0 {
		c.setZero()
	}
	if c.a&0b10000000 != 0 {
		c.setNegative()
	}
	c.cycleDelay = 2
	c.pc += 2
}

// asl: arithmetic shift left (accumulator)
func arithmeticShiftLeftAccumulator(c *Cpu) {
}

// ora: bitwise or (absolute)
func bitwiseOrAbsolute(c *Cpu) {
}

// asl: arithmetic shift left (absolute)
func arithmeticShiftLeftAbsolute(c *Cpu) {
}

// bpl: branch if plus (relative)
func branchIfPlusRelative(c *Cpu) {
}

// ora: bitwise or (indirect, y-indexed)
func bitwiseOrIndirectY(c *Cpu) {
}

// ora: bitwise or (zero page, x-indexed)
func bitwiseOrZeroPageX(c *Cpu) {
}

// asl: arithmetic shift left (zero page, x-indexed)
func arithmeticShiftLeftZeroPageX(c *Cpu) {
}

// clc: clear carry
func clearCarry(c *Cpu) {
}

// ora: bitwise or (absolute, y-indexed)
func bitwiseOrAbsoluteY(c *Cpu) {
}

// ora: bitwise or (absolute, x-indexed)
func bitwiseOrAbsoluteX(c *Cpu) {
}

// asl: arithmetic shift left (absolute, x-indexed)
func arithmeticShiftLeftAbsoluteX(c *Cpu) {
}

// jsr: jump to subroutine (absolute)
func jumpToSubroutineAbsolute(c *Cpu) {
}

// and: bitwise and (x-indexed, indirect)
func bitwiseAndIndirectX(c *Cpu) {
}

// bit: bit test (zero page)
func bitTestZeroPage(c *Cpu) {
}

// and: bitwise and (zero page)
func bitwiseAndZeroPage(c *Cpu) {
}

// rol: rotate left (zero page)
func rotateLeftZeroPage(c *Cpu) {
}

// plp: pull processor status
func pullProcessorStatus(c *Cpu) {
}

// and: bitwise and (immediate)
func bitwiseAndImmediate(c *Cpu) {
	value := c.memory[c.pc+1]
	c.a &= value
	if c.a == 0 {
		c.setZero()
	}
	if c.a&0b10000000 != 0 {
		c.setNegative()
	}
	c.cycleDelay = 2
	c.pc += 2
}

// rol: rotate left (accumulator)
func rotateLeftAccumulator(c *Cpu) {
}

// bit: bit test (absolute)
func bitTestAbsolute(c *Cpu) {
}

// and: bitwise and (absolute)
func bitwiseAndAbsolute(c *Cpu) {
}

// rol: rotate left (absolute)
func rotateLeftAbsolute(c *Cpu) {
}

// bmi: branch if minus (relative)
func branchIfMinusRelative(c *Cpu) {
}

// and: bitwise and (indirect, y-indexed)
func bitwiseAndIndirectY(c *Cpu) {
}

// and: bitwise and (zero page, x-indexed)
func bitwiseAndZeroPageX(c *Cpu) {
}

// rol: rotate left (zero page, x-indexed)
func rotateLeftZeroPageX(c *Cpu) {
}

// sec: set carry
func setCarry(c *Cpu) {
	c.setCarry()
	c.cycleDelay = 2
	c.pc++
}

// and: bitwise and (absolute, y-indexed)
func bitwiseAndAbsoluteY(c *Cpu) {
}

// and: bitwise and (absolute, x-indexed)
func bitwiseAndAbsoluteX(c *Cpu) {
}

// rol: rotate left (absolute, x-indexed)
func rotateLeftAbsoluteX(c *Cpu) {
}

// rti: return from interrupt
func returnFromInterrupt(c *Cpu) {
	c.status = c.stackPop() | 0b11001111
	pcByte2 := c.stackPop()
	var pcByte1 uint16 = uint16(c.stackPop())
	c.pc = pcByte1<<8 | uint16(pcByte2)
	c.cycleDelay = 6
	c.pc++
}

// eor: bitwise exclusive or (x-indexed, indirect)
func bitwiseXorIndirectX(c *Cpu) {
}

// eor: bitwise exclusive or (zero page)
func bitwiseXorZeroPage(c *Cpu) {
}

// lsr: logical shift right (zero page)
func logicalShiftRightZeroPage(c *Cpu) {
}

// pha: push a
func pushA(c *Cpu) {
}

// eor: bitwise exclusive or (immediate)
func bitwiseXorImmediate(c *Cpu) {
}

// lsr: logical shift right (accumulator)
func logicalShiftRightAccumulator(c *Cpu) {
}

// jmp: jump (absolute)
func jumpAbsolute(c *Cpu) {
}

// eor: bitwise exclusive or (absolute)
func bitwiseXorAbsolute(c *Cpu) {
}

// lsr: logical shift right (absolute)
func logicalShiftRightAbsolute(c *Cpu) {
}

// bvc: branch if overflow clear (relative)
func branchIfOverflowClearRelative(c *Cpu) {
}

// eor: bitwise exclusive or (indirect, y-indexed)
func bitwiseXorIndirectY(c *Cpu) {
}

// eor: bitwise exclusive or (zero page, x-indexed)
func bitwiseXorZeroPageX(c *Cpu) {
}

// lsr: logical shift right (zero page, x-indexed)
func logicalShiftRightZeroPageX(c *Cpu) {
}

// cli: clear interrupt disable
func clearInterruptDisable(c *Cpu) {
}

// eor: bitwise exclusive or (absolute, y-indexed)
func bitwiseXorAbsoluteY(c *Cpu) {
}

// eor: bitwise exclusive or (absolute, x-indexed)
func bitwiseXorAbsoluteX(c *Cpu) {
}

// lsr: logical shift right (absolute, x-indexed)
func logicalShiftRightAbsoluteX(c *Cpu) {
}

// rts: return from subroutine
func returnFromSubroutine(c *Cpu) {
}

// adc: add with carry (x-indexed, indirect)
func addWithCarryIndirectX(c *Cpu) {
}

// adc: add with carry (zero page)
func addWithCarryZeroPage(c *Cpu) {
}

// ror: rotate right (zero page)
func rotateRightZeroPage(c *Cpu) {
}

// pla: pull a
func pullA(c *Cpu) {
}

// adc: add with carry (immediate)
func addWithCarryImmediate(c *Cpu) {
}

// ror: rotate right (accumulator)
func rotateRightAccumulator(c *Cpu) {
}

// jmp: jump (indirect)
func jumpIndirect(c *Cpu) {
}

// adc: add with carry (absolute)
func addWithCarryAbsolute(c *Cpu) {
}

// ror: rotate right (absolute)
func rotateRightAbsolute(c *Cpu) {
}

// bvs: branch if overflow set (relative)
func branchIfOverflowSetRelative(c *Cpu) {
}

// adc: add with carry (indirect, y-indexed)
func addWithCarryIndirectY(c *Cpu) {
}

// adc: add with carry (zero page, x-indexed)
func addWithCarryZeroPageX(c *Cpu) {
}

// ror: rotate right (zero page, x-indexed)
func rotateRightZeroPageX(c *Cpu) {
}

// sei: set interrupt disable
func setInterruptDisable(c *Cpu) {
}

// adc: add with carry (absolute, y-indexed)
func addWithCarryAbsoluteY(c *Cpu) {
}

// adc: add with carry (absolute, x-indexed)
func addWithCarryAbsoluteX(c *Cpu) {
}

// ror: rotate right (absolute, x-indexed)
func rotateRightAbsoluteX(c *Cpu) {
}

// sta: store a (x-indexed, indirect)
func storeAIndirectX(c *Cpu) {
}

// sty: store y (zero page)
func storeYZeroPage(c *Cpu) {
}

// sta: store a (zero page)
func storeAZeroPage(c *Cpu) {
}

// stx: store x (zero page)
func storeXZeroPage(c *Cpu) {
}

// dey: decrement y
func decrementY(c *Cpu) {
}

// txa: transfer x to a
func transferXToA(c *Cpu) {
}

// sty: store y (absolute)
func storeYAbsolute(c *Cpu) {
}

// sta: store a (absolute)
func storeAAbsolute(c *Cpu) {
}

// stx: store x (absolute)
func storeXAbsolute(c *Cpu) {
}

// bcc: branch if carry clear (relative)
func branchIfCarryClearRelative(c *Cpu) {
}

// sta: store a (indirect, y-indexed)
func storeAIndirectY(c *Cpu) {
}

// sty: store y (zero page, x-indexed)
func storeYZeroPageX(c *Cpu) {
}

// sta: store a (zero page, x-indexed)
func storeAZeroPageX(c *Cpu) {
}

// stx: store x (zero page, y-indexed)
func storeXZeroPageY(c *Cpu) {
}

// tya: transfer y to a
func transferYToA(c *Cpu) {
}

// sta: store a (absolute, y-indexed)
func storeAAbsoluteY(c *Cpu) {
}

// txs: transfer x to stack pointer
func transferXToStackPointer(c *Cpu) {
}

// sta: store a (absolute, x-indexed)
func storeAAbsoluteX(c *Cpu) {
}

// ldy: load y (immediate)
func loadYImmediate(c *Cpu) {
}

// lda: load a (x-indexed, indirect)
func loadAIndirectX(c *Cpu) {
}

// ldx: load x (immediate)
func loadXImmediate(c *Cpu) {
}

// ldy: load y (zero page)
func loadYZeroPage(c *Cpu) {
}

// lda: load a (zero page)
func loadAZeroPage(c *Cpu) {
}

// ldx: load x (zero page)
func loadXZeroPage(c *Cpu) {
}

// tay: transfer a to y
func transferAToY(c *Cpu) {
}

// lda: load a (immediate)
func loadAImmediate(c *Cpu) {
}

// tax: transfer a to x
func transferAToX(c *Cpu) {
}

// ldy: load y (absolute)
func loadYAbsolute(c *Cpu) {
}

// lda: load a (absolute)
func loadAAbsolute(c *Cpu) {
}

// ldx: load x (absolute)
func loadXAbsolute(c *Cpu) {
}

// bcs: branch if carry set (relative)
func branchIfCarrySetRelative(c *Cpu) {
}

// lda: load a (indirect, y-indexed)
func loadAIndirectY(c *Cpu) {
}

// ldy: load y (zero page, x-indexed)
func loadYZeroPageX(c *Cpu) {
}

// lda: load a (zero page, x-indexed)
func loadAZeroPageX(c *Cpu) {
}

// ldx: load x (zero page, y-indexed)
func loadXZeroPageY(c *Cpu) {
}

// clv: clear overflow
func clearOverflow(c *Cpu) {
}

// lda: load a (absolute, y-indexed)
func loadAAbsoluteY(c *Cpu) {
}

// tsx: transfer stack pointer to x
func transferStackPointerToX(c *Cpu) {
}

// ldy: load y (absolute, x-indexed)
func loadYAbsoluteX(c *Cpu) {
}

// lda: load a (absolute, x-indexed)
func loadAAbsoluteX(c *Cpu) {
}

// ldx: load x (absolute, y-indexed)
func loadXAbsoluteY(c *Cpu) {
}

// cpy: compare y (immediate)
func compareYImmediate(c *Cpu) {
}

// cpa: compare a (x-indexed, indirect)
func compareAIndirectX(c *Cpu) {
}

// cpy: compare y (zero page)
func compareYZeroPage(c *Cpu) {
}

// cpa: compare a (zero page)
func compareAZeroPage(c *Cpu) {
}

// dec: decrement memory (zero page)
func decrementMemoryZeroPage(c *Cpu) {
}

// iny: increment y
func incrementY(c *Cpu) {
}

// cmp: compare a (immediate)
func compareAImmediate(c *Cpu) {
}

// dex: decrement x
func decrementX(c *Cpu) {
}

// cpy: compare y (absolute)
func compareYAbsolute(c *Cpu) {
}

// cmp: compare a (absolute)
func compareAAbsolute(c *Cpu) {
}

// dec: decrement memory (absolute)
func decrementMemoryAbsolute(c *Cpu) {
}

// bne: branch if not equal (relative)
func branchIfNotEqualRelative(c *Cpu) {
}

// cmp: compare a (indirect, y-indexed)
func compareAIndirectY(c *Cpu) {
}

// cmp: compare a (zero page, x-indexed)
func compareAZeroPageX(c *Cpu) {
}

// dec: decrement memory (zero page, x-indexed)
func decrementMemoryZeroPageX(c *Cpu) {
}

// cld: clear decimal
func clearDecimal(c *Cpu) {
}

// cmp: compare a (absolute, y-indexed)
func compareAAbsoluteY(c *Cpu) {
}

// cmp: compare a (absolute, x-indexed)
func compareAAbsoluteX(c *Cpu) {
}

// dec: decrement memory (absolute, x-indexed)
func decrementMemoryAbsoluteX(c *Cpu) {
}

// cpx: compare x (immediate)
func compareXImmediate(c *Cpu) {
}

// sbc: subtract with carry (x-indexed, indirect)
func subtractWithCarryIndirectX(c *Cpu) {
}

// cpx: compare x (zero page)
func compareXZeroPage(c *Cpu) {
}

// sbc: subtract with carry (zero page)
func subtractWithCarryZeroPage(c *Cpu) {
}

// inc: increment memory (zero page)
func incrementMemoryZeroPage(c *Cpu) {
}

// inx: increment x
func incrementX(c *Cpu) {
}

// sbc: subtract with carry (immediate)
func subtractWithCarryImmediate(c *Cpu) {
}

// nop: no operation
func noOperation(c *Cpu) {
}

// cpx: compare x (absolute)
func compareXAbsolute(c *Cpu) {
}

// sbc: subtract with carry (absolute)
func subtractWithCarryAbsolute(c *Cpu) {
}

// inc: increment memory (absolute)
func incrememtMemoryAbsolute(c *Cpu) {
}

// beq: branch if equal (relative)
func branchIfEqualRelative(c *Cpu) {
}

// sbc: subtract with carry (indirect, y-indexed)
func subtractWithCarryIndirectY(c *Cpu) {
}

// sbc: subtract with carry (zero page, x-indexed)
func subtractWithCarryZeroPageX(c *Cpu) {
}

// inc: increment memory (zero page, x-indexed)
func incrementMemoryZeroPageX(c *Cpu) {
}

// sed: set decimal
func setDecimal(c *Cpu) {
}

// sbc: subtract with carry (absolute, y-indexed)
func subtractWithCarryAbsoluteY(c *Cpu) {
}

// sbc: subtract with carry (absolute, x-indexed)
func subtractWithCarryAbsoluteX(c *Cpu) {
}

// inc: increment memory (absolute, x-indexed)
func incrementMemoryAbsoluteX(c *Cpu) {
}
